---
slug: code-offer-integer-binary
title: 02-二进制运算
date: 2023-12-03
author: zhouJun134
tags: [java, 剑指offer, 整数, 二进制]
keywords: [剑指offer, 算法题, 整数, 二进制]
---

# 02 二进制

二进制的位运算主要有 6 种：非，与，或，异或，左移和右移。

![image-20231203235121198](https://img.zbus.top//zbus/blog/202312032351778.webp)

## 2.1 二进制的 6 种运算
#### 非运算

非运算对整数的二进制按位取反，0 取反得 1, 1 取反得 0，下面对 8 为整数进行非运算：

~ 00001010 = 11110101

~ 10001010 = 01110101

### 与，或和异或的运算规律如下表：

|    运算符    |   计算1    |   计算2    |   计算3    | 计算4      |
| :----------: | :--------: | :--------: | :--------: | ---------- |
|   与 ( & )   | 0 & 0 = 0  | 1 & 0 = 0  | 0 & 1 = 0  | 1 & 1 = 1  |
|  或 ( \| )   | 0 \| 0 = 0 | 1 \| 0 = 1 | 0 \| 1 = 1 | 1 \| 1 = 1 |
| 异或 （ ^ ） | 0 ^ 0 = 0  | 1 ^ 0 = 1  | 0 ^ 1 = 1  | 1 ^ 1 = 1  |

### 左移运算符

左移运算符 `m << n` 表示把 m 左移 n 位。如果左移 n 位，那么最左边的 n 位将被丢弃，同时在最右边补上 n 个 0。具体示例如下：

00001010 << 2 = 00101000

10001010 << 3 = 01010000

### 右移运算符

右移运算符 `m >> n` 表示把 m 右移 n 位。如果右移 n 位，那么最右边的 n 位将被丢弃，但右移时处理最左边位的情形比较复杂。如果数字是一个无符号数值，则用 0 填补最左边的 n 位。如果数字是一个有符号数值，则用数字的符号位填补最左边的 n 位。也就是说，如果数字原先是一个正数，则右移之后在最左边补 n 个 0；如果数字原先是一个负数，则右移之后在最左边补 n 个 1。 值（Java中的byte型整数）进行右移的例子：

00001010 >> 2 = 00000010

10001010 >> 3 = 11110001

Java 中增加了一种无符号右移位操作符 “ >>>”。无论是对正数还是负数进行无符号右移操作，都将在最左边插入 0。下面是对 Java 中 byte 型整数进行无符号右移操作的例子：

00001010 >>> 2=00000010

10001010 >>> 3=00010001

其他编程语言（如C或C++）中没有无符号右移位操作符。




## 题目 2: 二进制加法

输入两个表示二进制的字符串，请计算它们的和，并以二进制字符串的形式输出。例如，输入的二进制字符串分别是"11"和"10"，则输出"101"。

### 分析

从右向左依次计算每一位的数字，如果大于等于2，进一位，直到计算完所有的字符。

==**注意** `java` 中，计算 `char` 的整数是 `字符 - '0' ` 比如： `char` 的字符 a，则对应的整数为 `a - '0'`==

### 代码

```java
package com.zj.offer.code;

import java.util.Objects;

/**
 * 作者: zhoujun134
 * 时间: 2023/12/3 22:34
 */
public class Test02 {
    public static void main(String[] args) {
        System.out.println(addBinary("11", "10"));
    }

    public static String addBinary(String str1, String str2) {
        int i = str1.length() - 1;
        int j = str2.length() - 1;
        int carry = 0;
        StringBuilder result = new StringBuilder();
        while (i >= 0 || j >= 0) {
            int digitA = i >= 0 ? str1.charAt(i--) - '0' : 0;
            int digitB = j >= 0 ? str2.charAt(j--) - '0' : 0;
            int sum = digitA + digitB + carry;
            carry = sum >= 2 ? 1 : 0;
            sum = sum >= 2 ? sum - 2 : sum;
            System.out.println(sum);
            result.append(sum);
        }
        if (carry == 1) {
            result.append(1);
        }
        return result.reverse().toString();
    }
}
```

## 题目 3:  前 n 个数字二进制形式中 1 的个数

题目：输入一个非负数 n，请计算 0 到 n 之间每个数字的二进制形式中 1 的个数，并输出一个数组。例如，输入的 n 为 4，由于 0、1、2、3、4 的二进制形式中 1 的个数分别为 0、1、1、2、1，因此输出数组[0，1，1，2，1]。

### 分析

#### 方法1 简单计算每个整数的二进制形式中1的个数

计算整数i的二进制形式中 1 的个数有多种不同的方法，其中一种比较高效的方法是每次用“`i &（i-1）`”将整数i的最右边的 1 变成 0。整数 i 减去1，那么它最右边的 1 变成 0。如果它的右边还有 0，则右边所有的 0 都变成 1，而其左边所有位都保持不变。下面对 i 和 `i -1`进行位与运算，相当于将其最右边的 1 变成 0。以二进制的1100 为例，它减去 1 的结果是 1011。1100 和 1011 的位与运算的结果正好是 1000。二进制的 1100 最右边的 1变为0，结果刚好就是 1000。

### 代码

```java
package com.zj.offer.code;

/**
 * 作者: zhoujun134
 * 时间: 2023/12/3 23:43
 */
public class Test3 {

    public static void main(String[] args) {
        int[] result = countBits(4);
        for (int i = 0; i < result.length; i++) {
            System.out.println(result[i]);
        }
    }
    public static int[] countBits(int num) {
        int[] result = new int[num + 1];
        for (int i = 0; i <= num; ++i) {
            int j = i;
            while (j != 0) {
                result[i]++;
                j = j & (j - 1);
            }
        }
        return result;
    }
}
```
